# ADR-003: Multi-Tenant Architecture with Schema-per-Tenant

**Status:** Accepted  
**Date:** 2025-08-08  
**Deciders:** Lead Solutions Architect, Product Owner, Security Architect  
**Technical Story:** Multi-League SaaS Platform Architecture  

## Context

The Basketball League Management Platform needs to support multiple independent leagues and organizations while maintaining:

1. **Data Isolation**: Complete separation of league data for security and compliance
2. **Cost Efficiency**: Shared infrastructure to minimize operational costs
3. **Scalability**: Ability to onboard hundreds of leagues without manual provisioning
4. **Customization**: League-specific configurations, rules, and branding
5. **Compliance**: COPPA requirements for youth data with strict privacy controls
6. **Performance**: No cross-tenant performance impact during high-traffic events

### Current State
- Single-tenant architecture serving one organization
- Manual deployment process for each new league
- No data isolation mechanisms
- Shared resources without tenant awareness

### Requirements
- Support 100+ leagues initially, scaling to 1000+ leagues
- Complete data isolation between tenants
- Automated tenant onboarding
- Per-tenant customization capabilities
- Consistent performance regardless of tenant size
- Cost allocation and usage tracking per tenant

## Decision

We will implement a **Schema-per-Tenant Multi-Tenant Architecture** with the following design:

### Tenancy Model
- **Tenant Identification**: Each league/organization is a separate tenant
- **Data Isolation**: Separate PostgreSQL schema per tenant
- **Shared Infrastructure**: Common application instances serving all tenants
- **Tenant Resolution**: Domain-based and header-based tenant identification

### Architecture Components

#### 1. Tenant Resolution Layer
```typescript
interface TenantResolver {
  resolveTenant(request: Request): Promise<TenantContext>;
}

// Resolution strategies:
// 1. Subdomain: {tenant}.basketballleague.com
// 2. Header: X-Tenant-ID
// 3. JWT claim: tenant_id in access token
```

#### 2. Data Layer Strategy
```sql
-- Shared database with tenant-specific schemas
CREATE SCHEMA tenant_league_a;
CREATE SCHEMA tenant_league_b;

-- Each schema contains complete data model
CREATE TABLE tenant_league_a.games (...);
CREATE TABLE tenant_league_a.teams (...);
CREATE TABLE tenant_league_a.players (...);
```

#### 3. Application Layer
```typescript
class TenantAwareService {
  constructor(private tenantContext: TenantContext) {}
  
  async findById(id: string): Promise<Entity> {
    const schema = this.tenantContext.getSchema();
    return this.repository.findById(id, schema);
  }
}
```

### Tenant Provisioning Process
1. **Registration**: New league signs up through onboarding portal
2. **Validation**: Verify organization details and payment method
3. **Provisioning**: Automated creation of tenant schema and default data
4. **Configuration**: League-specific settings, rules, and customizations
5. **Activation**: DNS configuration and access credentials

## Alternatives Considered

### Alternative 1: Shared Database with Row-Level Security
**Pros:**
- Single schema to maintain
- Easier migrations and updates
- Lower storage overhead
- Simpler backup/restore

**Cons:**
- Risk of data leakage through application bugs
- Complex row-level security rules
- Performance impact of security filtering
- Difficult to provide tenant-specific customizations

**Rejected:** Security risks too high for youth sports data compliance.

### Alternative 2: Database-per-Tenant
**Pros:**
- Maximum data isolation
- Independent scaling per tenant
- Tenant-specific backups and recovery
- Complete customization flexibility

**Cons:**
- Very high operational overhead
- Expensive at scale (100+ databases)
- Complex connection pooling
- Difficult cross-tenant analytics

**Rejected:** Operational complexity and cost prohibitive.

### Alternative 3: Tenant ID in Shared Tables
**Pros:**
- Simplest to implement initially
- Single database to manage
- Easy cross-tenant analytics
- Standard ORM patterns

**Cons:**
- High risk of data leakage
- No physical data isolation
- Difficult to meet compliance requirements
- Performance issues with large tenant data

**Rejected:** Insufficient data isolation for compliance requirements.

### Alternative 4: Hybrid Schema-per-Tenant with Shared Tables
**Pros:**
- Good balance of isolation and efficiency
- Shared configuration and reference data
- Tenant-specific business data isolation
- Manageable operational complexity

**Cons:**
- More complex than pure schema-per-tenant
- Requires careful design of shared vs isolated data
- Migration complexity for shared data changes

**Considered but not selected:** Added complexity not justified for current requirements.

## Consequences

### Positive Consequences

#### Data Security and Isolation
- **Complete Data Separation**: No possibility of cross-tenant data access
- **Compliance Friendly**: Easy to demonstrate data isolation for audits
- **Tenant-specific Encryption**: Can implement tenant-specific encryption keys
- **Backup Isolation**: Independent backup and recovery per tenant

#### Operational Benefits
- **Independent Scaling**: Can optimize resources per tenant
- **Tenant-specific Maintenance**: Maintenance windows per tenant
- **Failure Isolation**: Tenant issues don't affect others
- **Usage Analytics**: Clear per-tenant resource usage tracking

#### Business Benefits
- **Customization**: Tenant-specific schema modifications possible
- **Pricing Flexibility**: Usage-based pricing models
- **Compliance**: Easier regulatory compliance per jurisdiction
- **Customer Confidence**: Clear data isolation story

### Negative Consequences

#### Operational Complexity
- **Schema Management**: Multiple schemas to maintain and migrate
- **Connection Pooling**: More complex database connection management
- **Monitoring**: Need tenant-aware monitoring and alerting
- **Backup Complexity**: More backup jobs and restore procedures

#### Development Complexity
- **Tenant Context**: All database operations must be tenant-aware
- **Testing**: More complex integration testing scenarios
- **Migrations**: Schema migrations must run across all tenants
- **Cross-tenant Features**: Difficult to implement cross-tenant analytics

#### Cost Implications
- **Storage Overhead**: Some data duplication across tenants
- **Connection Overhead**: More database connections required
- **Operational Tools**: Need tenant-aware tooling and dashboards

### Mitigation Strategies

#### For Operational Complexity
- **Infrastructure as Code**: Automated tenant provisioning and management
- **Monitoring Dashboards**: Tenant-aware monitoring with aggregated views
- **Migration Tools**: Automated schema migration across all tenants
- **Backup Automation**: Automated per-tenant backup and rotation

#### For Development Complexity  
- **Tenant Context Injection**: Middleware to automatically inject tenant context
- **Repository Patterns**: Abstract tenant-aware data access patterns
- **Testing Frameworks**: Multi-tenant testing utilities and fixtures
- **Documentation**: Clear patterns and examples for developers

#### For Cost Management
- **Connection Pooling**: Sophisticated pooling to minimize connections
- **Shared Services**: Common services (notifications, payments) shared across tenants
- **Resource Monitoring**: Per-tenant resource usage tracking and optimization

## Implementation Details

### Tenant Resolution Implementation
```typescript
// Tenant resolution middleware
export class TenantResolutionMiddleware {
  async resolve(req: Request, res: Response, next: NextFunction) {
    let tenantId: string | null = null;
    
    // Strategy 1: Subdomain resolution
    if (req.subdomains.length > 0) {
      tenantId = req.subdomains[0];
    }
    
    // Strategy 2: Header-based resolution
    if (!tenantId && req.headers['x-tenant-id']) {
      tenantId = req.headers['x-tenant-id'] as string;
    }
    
    // Strategy 3: JWT token resolution
    if (!tenantId && req.user?.tenantId) {
      tenantId = req.user.tenantId;
    }
    
    if (!tenantId) {
      return res.status(400).json({ error: 'Tenant not specified' });
    }
    
    // Load and validate tenant
    const tenant = await this.tenantService.getTenant(tenantId);
    if (!tenant || !tenant.isActive) {
      return res.status(404).json({ error: 'Tenant not found' });
    }
    
    // Set tenant context
    req.tenantContext = new TenantContext(tenant);
    next();
  }
}
```

### Database Connection Management
```typescript
// Tenant-aware database service
export class MultiTenantDatabase {
  private connectionPools = new Map<string, Pool>();
  
  async getConnection(tenantId: string): Promise<PoolClient> {
    let pool = this.connectionPools.get(tenantId);
    
    if (!pool) {
      pool = new Pool({
        ...this.baseConfig,
        database: this.baseConfig.database,
        schema: `tenant_${tenantId}`,
        max: this.getTenantPoolSize(tenantId)
      });
      
      this.connectionPools.set(tenantId, pool);
    }
    
    return pool.connect();
  }
  
  private getTenantPoolSize(tenantId: string): number {
    // Dynamic pool sizing based on tenant tier
    const tenant = this.tenantRegistry.get(tenantId);
    return tenant?.tier === 'enterprise' ? 20 : 10;
  }
}
```

### Automated Tenant Provisioning
```typescript
// Tenant provisioning service
export class TenantProvisioningService {
  async provisionTenant(request: TenantProvisioningRequest): Promise<Tenant> {
    const tenantId = this.generateTenantId(request.organizationName);
    
    try {
      // Step 1: Create database schema
      await this.createTenantSchema(tenantId);
      
      // Step 2: Run schema migrations
      await this.runSchemaMigrations(tenantId);
      
      // Step 3: Seed default data
      await this.seedDefaultData(tenantId, request);
      
      // Step 4: Configure tenant settings
      const tenant = await this.createTenantRecord(tenantId, request);
      
      // Step 5: Set up monitoring and alerting
      await this.setupTenantMonitoring(tenantId);
      
      // Step 6: Configure DNS (if subdomain)
      if (request.subdomain) {
        await this.configureDNS(request.subdomain, tenantId);
      }
      
      return tenant;
    } catch (error) {
      // Rollback on failure
      await this.rollbackTenantProvisioning(tenantId);
      throw error;
    }
  }
  
  private async createTenantSchema(tenantId: string): Promise<void> {
    const schemaName = `tenant_${tenantId}`;
    
    await this.database.query(`CREATE SCHEMA ${schemaName}`);
    
    // Grant permissions
    await this.database.query(`
      GRANT USAGE ON SCHEMA ${schemaName} TO app_user;
      GRANT CREATE ON SCHEMA ${schemaName} TO app_user;
    `);
  }
}
```

## Migration Strategy

### Phase 1: Infrastructure Setup (Month 1)
1. Implement tenant resolution middleware
2. Create multi-tenant database connection management
3. Build tenant provisioning automation
4. Set up tenant-aware monitoring

### Phase 2: Application Updates (Month 2)
1. Update all services to be tenant-aware
2. Implement tenant context injection
3. Update all database queries to use tenant schemas
4. Test multi-tenant functionality

### Phase 3: Data Migration (Month 3)
1. Create migration tools for existing data
2. Provision schemas for existing organizations
3. Migrate data to tenant-specific schemas
4. Validate data integrity and performance

### Phase 4: Production Rollout (Month 4)
1. Deploy multi-tenant architecture to production
2. Onboard pilot tenants
3. Monitor performance and fix issues
4. Scale to additional tenants

## Security Considerations

### Tenant Isolation
- Database-level isolation through schemas
- Application-level tenant context validation
- Network-level isolation where possible
- Audit logging of all cross-tenant access attempts

### Authentication and Authorization
- Tenant-aware user authentication
- Role-based access control within tenants
- Prevent privilege escalation across tenants
- Multi-factor authentication for admin users

### Data Protection
- Tenant-specific encryption keys where required
- Secure tenant onboarding and offboarding
- Data retention policies per tenant
- Secure backup and recovery procedures

## Performance Considerations

### Database Performance
- Connection pooling optimization per tenant
- Query performance monitoring per tenant
- Index optimization for tenant-specific queries
- Automated scaling based on tenant usage

### Application Performance
- Tenant context caching
- Per-tenant performance monitoring
- Resource allocation based on tenant tier
- Auto-scaling triggers per tenant load

### Monitoring and Alerting
- Tenant-specific performance dashboards
- Cross-tenant performance comparison
- Automated alerting for tenant-specific issues
- Usage analytics and capacity planning

## Cost Management

### Resource Allocation
- Tenant-specific resource quotas
- Usage-based billing calculations
- Cost allocation per tenant
- Automated cost optimization recommendations

### Infrastructure Optimization
- Shared infrastructure where possible
- Tenant tier-based resource allocation
- Automated scaling to reduce waste
- Regular cost analysis and optimization

## Success Metrics

### Technical Metrics
- Tenant provisioning time: <10 minutes
- Zero cross-tenant data access incidents
- Database performance: <100ms query response (95th percentile)
- System availability: >99.9% per tenant

### Business Metrics
- Tenant onboarding conversion rate: >80%
- Average time to value for new tenants: <24 hours
- Customer satisfaction score: >4.5/5.0
- Support ticket volume per tenant: <5/month

### Operational Metrics
- Automated provisioning success rate: >99%
- Schema migration success rate: >99.5%
- Mean time to resolution for tenant issues: <2 hours
- Infrastructure cost per tenant: <$50/month

## Review and Maintenance

### Regular Reviews
- **Quarterly**: Performance and cost analysis per tenant
- **Semi-annual**: Security audit of tenant isolation
- **Annual**: Architecture review and optimization opportunities

### Maintenance Activities
- **Monthly**: Schema migration deployment across tenants
- **Weekly**: Performance monitoring and optimization
- **Daily**: Backup validation and monitoring
- **Continuous**: Security monitoring and alerting

This ADR will be reviewed in 6 months (February 2026) to evaluate the effectiveness of the multi-tenant architecture and identify areas for improvement.