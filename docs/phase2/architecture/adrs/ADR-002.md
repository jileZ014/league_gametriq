# ADR-002: CQRS with Event Sourcing for Game Operations

**Status:** Accepted  
**Date:** 2025-08-08  
**Deciders:** Lead Solutions Architect, Technical Lead, Game Operations Team Lead  
**Technical Story:** Real-time Game State Management and Historical Analytics  

## Context

The Game Operations service is the most critical component for real-time functionality, requiring:

1. **Real-time Updates**: Game state changes must be broadcast to all connected clients within 100ms
2. **Audit Requirements**: Complete audit trail of all game events for compliance and dispute resolution
3. **Analytics Needs**: Rich historical data for player performance, coaching insights, and league statistics
4. **Offline Support**: Mobile scorekeeping apps must work offline and sync when connectivity returns
5. **High Concurrency**: Multiple users (scorekeepers, coaches, spectators) accessing game data simultaneously

### Current Challenges with Traditional CRUD
- Read operations compete with write operations for database resources
- Complex queries for analytics impact real-time performance
- Difficult to maintain complete audit trail
- Offline synchronization creates data conflicts
- Traditional databases struggle with high read loads during tournaments

## Decision

We will implement **CQRS (Command Query Responsibility Segregation) with Event Sourcing** for the Game Operations service:

### Architecture Components

#### 1. Command Side (Write Model)
- **Game Aggregate**: Handles all business logic and state transitions
- **Command Handlers**: Process game commands (start game, record score, etc.)
- **Event Store**: DynamoDB for storing domain events (append-only)
- **Event Bus**: AWS EventBridge for publishing domain events

#### 2. Query Side (Read Models)
- **Game State Read Model**: Current game state in Redis for real-time queries
- **Statistics Read Model**: PostgreSQL optimized for analytics queries
- **Search Read Model**: Elasticsearch for complex game searches
- **Historical Read Model**: S3 + Athena for long-term analytics

#### 3. Event Processing
- **Event Handlers**: Update read models when domain events occur
- **Projections**: Create different views of the same event stream
- **Catch-up Subscriptions**: Rebuild read models from event history

### Implementation Pattern

```typescript
// Command Side - Game Aggregate with Event Sourcing
export class Game extends AggregateRoot {
  // Domain logic and business rules
  recordScore(teamId: TeamId, playerId: PlayerId, points: Points): void {
    // Business rule validation
    this.ensureGameInProgress();
    this.ensureValidTeam(teamId);
    
    // State change
    const event = new ScoreRecordedEvent({
      gameId: this.id,
      teamId, playerId, points,
      timestamp: new Date()
    });
    
    this.addEvent(event); // Will be stored in event store
  }
  
  // Rebuild from event history
  static fromHistory(events: DomainEvent[]): Game {
    const game = new Game();
    events.forEach(event => game.applyEvent(event));
    return game;
  }
}

// Query Side - Read Model Projections
export class GameStateProjection {
  async handle(event: ScoreRecordedEvent): Promise<void> {
    // Update real-time read model in Redis
    await this.redis.hset(
      `game:${event.gameId}:state`,
      'score',
      JSON.stringify(event.newScore)
    );
    
    // Broadcast to WebSocket clients
    await this.websocketService.broadcast(
      `game:${event.gameId}`,
      'score-update',
      event
    );
  }
}
```

## Alternatives Considered

### Alternative 1: Traditional CRUD with Database Replication
**Pros:**
- Familiar pattern for developers
- Simpler initial implementation
- Standard ORM support

**Cons:**
- Read/write contention during high traffic
- Complex caching invalidation
- Difficult to implement complete audit trail
- Limited offline synchronization support

**Rejected:** Cannot meet real-time performance requirements under tournament load.

### Alternative 2: Simple Event Streaming without Event Sourcing
**Pros:**
- Easier to implement than full event sourcing
- Good performance for real-time updates
- Simpler data model

**Cons:**
- Loss of historical state if read models corrupted
- Difficult to implement complex business logic
- Limited ability to replay events for debugging
- No built-in audit trail

**Rejected:** Insufficient for audit requirements and data recovery needs.

### Alternative 3: Hybrid Approach with Separate Audit Log
**Pros:**
- Familiar CRUD patterns for main data
- Separate audit logging system
- Can optimize each system independently

**Cons:**
- Dual writes create consistency issues
- Audit log can become out of sync
- Still has read/write contention issues
- More complex than pure event sourcing

**Rejected:** Consistency issues and complexity outweigh benefits.

## Consequences

### Positive Consequences
- **Performance**: Separated read/write workloads enable independent optimization
- **Scalability**: Read models can be scaled independently based on query patterns
- **Audit Trail**: Complete event history provides perfect audit trail
- **Flexibility**: Multiple read models optimized for different use cases
- **Real-time**: Event-driven architecture enables sub-100ms updates
- **Offline Support**: Event-based synchronization handles offline scenarios
- **Debugging**: Can replay events to reproduce any system state
- **Analytics**: Rich event data enables advanced analytics and ML features

### Negative Consequences
- **Complexity**: More complex than traditional CRUD approach
- **Eventual Consistency**: Read models may be temporarily inconsistent
- **Learning Curve**: Team needs to learn event sourcing patterns
- **Operational Overhead**: More components to monitor and maintain
- **Storage Costs**: Event store grows continuously (append-only)

### Risk Mitigation

#### Complexity Management
- Provide comprehensive documentation and training
- Implement clear patterns and abstractions
- Use established libraries (EventStore, Axon Framework concepts)

#### Eventual Consistency Handling
- Design UI to handle eventual consistency gracefully
- Implement proper error handling and retry mechanisms
- Use optimistic locking for critical operations

#### Operational Concerns
- Implement comprehensive monitoring and alerting
- Set up automated event store backup and recovery
- Establish clear incident response procedures

## Implementation Details

### Event Store Schema (DynamoDB)
```json
{
  "StreamId": "game-{gameId}",
  "EventNumber": 123,
  "EventType": "ScoreRecorded",
  "EventData": {
    "gameId": "uuid",
    "teamId": "uuid", 
    "playerId": "uuid",
    "points": 2,
    "timestamp": "2025-08-08T19:30:00Z"
  },
  "EventMetadata": {
    "causationId": "command-uuid",
    "correlationId": "request-uuid",
    "userId": "scorer-uuid"
  },
  "EventTimestamp": "2025-08-08T19:30:00.123Z"
}
```

### Read Model Examples
```typescript
// Real-time Game State (Redis)
interface GameStateReadModel {
  gameId: string;
  homeTeam: { id: string; score: number; };
  awayTeam: { id: string; score: number; };
  status: 'scheduled' | 'in_progress' | 'completed';
  currentPeriod: number;
  timeRemaining: string;
  lastUpdated: string;
}

// Analytics Read Model (PostgreSQL)
interface GameStatisticsReadModel {
  gameId: string;
  playerId: string;
  points: number;
  fieldGoals: number;
  freeThrows: number;
  rebounds: number;
  assists: number;
  fouls: number;
  minutesPlayed: number;
}
```

### Event Processing Pipeline
1. **Command Handler** validates business rules and generates events
2. **Event Store** persists events to DynamoDB
3. **Event Bus** publishes events to EventBridge
4. **Event Handlers** update appropriate read models
5. **WebSocket Service** broadcasts updates to connected clients

## Success Criteria

### Performance Metrics
- Event write latency: <50ms (99th percentile)
- Read model update latency: <100ms (95th percentile)
- WebSocket broadcast latency: <100ms (95th percentile)
- Event store query performance: <10ms (95th percentile)

### Functional Metrics  
- Zero data loss during offline synchronization
- Complete audit trail for all game events
- Read model consistency within 1 second of event occurrence
- Support for 1000+ concurrent game viewers

### Operational Metrics
- Event store availability: >99.9%
- Read model rebuild time: <30 minutes for full history
- Storage growth: <1GB per month per active league

## Migration Strategy

### Phase 1: Parallel Implementation (Month 1)
- Implement event sourcing for new games
- Maintain existing CRUD for historical data
- Build read model projections

### Phase 2: Gradual Migration (Month 2)
- Migrate active games to event sourcing
- Implement event migration tools
- Update client applications

### Phase 3: Full Migration (Month 3)
- Complete historical data migration
- Remove old CRUD endpoints
- Optimize read model performance

## Monitoring and Observability

### Key Metrics to Track
- **Event Processing Latency**: Time from command to read model update
- **Event Store Growth Rate**: Storage consumption trends
- **Read Model Consistency**: Lag time between events and projections
- **Error Rates**: Event processing failures and retries
- **Business Metrics**: Games processed, scores recorded, users active

### Alerting Thresholds
- Event processing latency >500ms (warning), >1s (critical)
- Read model lag >5 seconds (warning), >30 seconds (critical)
- Event processing error rate >1% (warning), >5% (critical)

## References

- [CQRS Pattern by Martin Fowler](https://martinfowler.com/bliki/CQRS.html)
- [Event Sourcing Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing)
- [DynamoDB as Event Store](https://aws.amazon.com/blogs/database/building-an-event-store-on-amazon-dynamodb/)
- [Versioning in an Event Sourced System](https://leanpub.com/esversioning)

## Review and Updates

This ADR will be reviewed quarterly to assess:
- Performance against established metrics
- Operational complexity and maintenance burden  
- Developer experience and productivity impact
- Business value delivery

Next review scheduled: November 2025